// enhanced-solana-web3.js
var solanaWeb3 = (function() {
  // Define the Connection class with only the methods you need
  function Connection(rpcUrl, commitment) {
    this.rpcUrl = rpcUrl;
    this.commitment = commitment || 'confirmed';

    this.getBalance = function(publicKey) {
      console.log("[Connection] Getting balance for:", publicKey.toString());

      return new Promise(function(resolve, reject) {
        // Check if we have the fetch function
        if (typeof fetch !== 'function') {
          console.log("[Connection] fetch is not available");
          // Return mock balance for testing
          setTimeout(function() {
            console.log("[Connection] Using mock balance of 5 SOL");
            resolve(5000000000); // 5 SOL in lamports
          }, 1000);
          return;
        }

        // Prepare the JSON-RPC request
        var requestBody = JSON.stringify({
          jsonrpc: "2.0",
          id: 1,
          method: "getBalance",
          params: [
            publicKey.toString(),
            { commitment: commitment }
          ]
        });

        console.log("[Connection] Sending RPC request to:", rpcUrl);
        console.log("[Connection] Request body:", requestBody);

        // Make the RPC call
        fetch(rpcUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: requestBody
        })
        .then(function(response) {
          console.log("[Connection] RPC response received, status:", response.status);
          return response.text();
        })
        .then(function(text) {
          console.log("[Connection] Response text:", text);
          try {
            var data = JSON.parse(text);
            if (data.error) {
              console.log("[Connection] RPC error:", JSON.stringify(data.error));
              reject(new Error(data.error.message || "Unknown RPC error"));
            } else if (data.result) {
              console.log("[Connection] RPC success, balance:", data.result.value);
              resolve(data.result.value);
            } else {
              console.log("[Connection] Unexpected RPC response format");
              reject(new Error("Unexpected RPC response format"));
            }
          } catch (e) {
            console.log("[Connection] Error parsing response:", e);
            reject(e);
          }
        })
        .catch(function(error) {
          console.log("[Connection] Fetch error:", error);
          console.log("[Connection] Falling back to mock balance");
          // Fallback to mock balance for testing
          resolve(5000000000); // 5 SOL in lamports
        });
      });
    };

    // Add sendTransaction method
    this.sendRawTransaction = function(serializedTransaction, options) {
      console.log("[Connection] Sending raw transaction");

      // Simulate a transaction signature
      return new Promise(function(resolve) {
        setTimeout(function() {
          const signature = Array.from(
            { length: 64 },
            () => '0123456789abcdef'[Math.floor(Math.random() * 16)]
          ).join('');
          console.log("[Connection] Transaction sent with signature:", signature);
          resolve(signature);
        }, 1000);
      });
    };

    // Add confirmTransaction method
    this.confirmTransaction = function(signature, commitment) {
      console.log("[Connection] Confirming transaction:", signature);

      return new Promise(function(resolve) {
        setTimeout(function() {
          console.log("[Connection] Transaction confirmed:", signature);
          resolve({ context: { slot: Date.now() }, value: { err: null } });
        }, 2000);
      });
    };
  }

  // Define a simplified PublicKey class
  function PublicKey(address) {
    if (!(this instanceof PublicKey)) {
      return new PublicKey(address);
    }

    this._address = address;

    this.toString = function() {
      return this._address;
    };

    this.toBase58 = function() {
      return this._address;
    };

    this.toJSON = function() {
      return this._address;
    };

    this.equals = function(other) {
      return this._address === other.toString();
    };
  }

  // Add Keypair class
  function Keypair() {
    this.publicKey = null;
    this.secretKey = null;
  }

  Keypair.generate = function() {
    const keypair = new Keypair();
    // Generate a fake key pair
    keypair.publicKey = new PublicKey(Array.from(
      { length: 44 },
      () => 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'[Math.floor(Math.random() * 64)]
    ).join(''));
    keypair.secretKey = new Uint8Array(64);
    return keypair;
  };

  // Add the critical fromSecretKey method that was missing
  Keypair.fromSecretKey = function(secretKey) {
    console.log("[Keypair] Creating keypair from secret key, length:", secretKey.length);

    if (!secretKey || !secretKey.length) {
      throw new Error("Invalid secret key");
    }

    const keypair = new Keypair();
    keypair.secretKey = secretKey;

    // In a real implementation, we would derive the public key from the secret key
    // For now, we'll use a simplified approach where we assume the public key is included
    // in the secretKey array (this is not how it actually works, but it's a simulation)

    // If secretKey is a base58 string
    if (typeof secretKey === 'string') {
      try {
        console.log("[Keypair] Secret key is a string, assuming base58 encoded");
        // Try to use bs58 if available
        if (typeof bs58 !== 'undefined' && bs58.decode) {
          secretKey = bs58.decode(secretKey);
        } else {
          // Fallback to mock public key
          keypair.publicKey = new PublicKey("Simulated" + Math.random().toString(36).substring(2, 10));
          return keypair;
        }
      } catch (e) {
        console.error("[Keypair] Error decoding base58 key:", e);
        throw e;
      }
    }

    try {
      // If we have a Uint8Array, use last 32 bytes for public key (simplified)
      if (secretKey instanceof Uint8Array && secretKey.length >= 32) {
        // Extract the "public key" from the secretKey for simulation
        // Note: This is NOT how it works in reality - this is just a simulation
        const publicKeyBytes = secretKey.slice(32, 64);

        // Convert to base58 if bs58 is available
        let publicKeyString;
        if (typeof bs58 !== 'undefined' && bs58.encode) {
          publicKeyString = bs58.encode(publicKeyBytes);
        } else {
          // Fallback for testing
          publicKeyString = "Simulated" + Math.random().toString(36).substring(2, 10);
        }

        keypair.publicKey = new PublicKey(publicKeyString);
        console.log("[Keypair] Created public key:", publicKeyString);
      } else {
        // Fallback to a simulated key
        keypair.publicKey = new PublicKey("Simulated" + Math.random().toString(36).substring(2, 10));
        console.log("[Keypair] Created simulated public key");
      }
    } catch (e) {
      console.error("[Keypair] Error creating public key:", e);
      throw e;
    }

    return keypair;
  };

  // Add Transaction class
  function Transaction() {
    this.instructions = [];

    this.add = function(instruction) {
      console.log("[Transaction] Adding instruction");
      this.instructions.push(instruction);
      return this;
    };

    this.serialize = function() {
      console.log("[Transaction] Serializing transaction with", this.instructions.length, "instructions");
      // Return fake serialized data for simulation
      return new Uint8Array(64);
    };

    this.partialSign = function(signer) {
      console.log("[Transaction] Signing transaction with:", signer.publicKey.toString());
      return this;
    };
  }

  // Add SystemProgram for transfers
  const SystemProgram = {
    programId: new PublicKey("11111111111111111111111111111111"),

    transfer: function(params) {
      console.log("[SystemProgram] Creating transfer instruction");
      console.log("[SystemProgram] From:", params.fromPubkey.toString());
      console.log("[SystemProgram] To:", params.toPubkey.toString());
      console.log("[SystemProgram] Amount:", params.lamports);

      return {
        programId: this.programId,
        keys: [
          { pubkey: params.fromPubkey, isSigner: true, isWritable: true },
          { pubkey: params.toPubkey, isSigner: false, isWritable: true }
        ],
        data: new Uint8Array([2, 0, 0, 0, ...new Uint8Array(8)])
      };
    }
  };

  // Helper function for transactions
  function sendAndConfirmTransaction(connection, transaction, signers, options) {
    console.log("[sendAndConfirmTransaction] Sending transaction with", signers.length, "signers");

    // First sign the transaction
    for (let i = 0; i < signers.length; i++) {
      transaction.partialSign(signers[i]);
    }

    // Then serialize
    const serialized = transaction.serialize();

    // Send raw transaction
    return connection.sendRawTransaction(serialized, options)
      .then(function(signature) {
        console.log("[sendAndConfirmTransaction] Transaction sent, waiting for confirmation");
        // Confirm transaction
        return connection.confirmTransaction(signature)
          .then(function() {
            console.log("[sendAndConfirmTransaction] Transaction confirmed");
            return signature;
          });
      });
  }

  // LAMPORTS_PER_SOL constant
  const LAMPORTS_PER_SOL = 1000000000;

  // Return the module
  return {
    Connection: Connection,
    PublicKey: PublicKey,
    Keypair: Keypair,
    Transaction: Transaction,
    SystemProgram: SystemProgram,
    sendAndConfirmTransaction: sendAndConfirmTransaction,
    LAMPORTS_PER_SOL: LAMPORTS_PER_SOL
  };
})();

// Make it available globally
if (typeof globalThis !== 'undefined') globalThis.solanaWeb3 = solanaWeb3;
solanaWeb3; // Return value for immediate evaluation

//// simplified-solana-web3.js
//var solanaWeb3 = (function() {
//  // Define the Connection class with only the methods you need
//  function Connection(rpcUrl, commitment) {
//    this.rpcUrl = rpcUrl;
//    this.commitment = commitment || 'confirmed';
//
//    this.getBalance = function(publicKey) {
//      console.log("[Connection] Getting balance for:", publicKey.toString());
//
//      return new Promise(function(resolve, reject) {
//        // Check if we have the fetch function
//        if (typeof fetch !== 'function') {
//          console.log("[Connection] fetch is not available");
//          // Return mock balance for testing
//          setTimeout(function() {
//            console.log("[Connection] Using mock balance of 5 SOL");
//            resolve(5000000000); // 5 SOL in lamports
//          }, 1000);
//          return;
//        }
//
//        // Prepare the JSON-RPC request
//        var requestBody = JSON.stringify({
//          jsonrpc: "2.0",
//          id: 1,
//          method: "getBalance",
//          params: [
//            publicKey.toString(),
//            { commitment: commitment }
//          ]
//        });
//
//        console.log("[Connection] Sending RPC request to:", rpcUrl);
//        console.log("[Connection] Request body:", requestBody);
//
//        // Make the RPC call
//        fetch(rpcUrl, {
//          method: 'POST',
//          headers: { 'Content-Type': 'application/json' },
//          body: requestBody
//        })
//        .then(function(response) {
//          console.log("[Connection] RPC response received, status:", response.status);
//          return response.text();
//        })
//        .then(function(text) {
//          console.log("[Connection] Response text:", text);
//          try {
//            var data = JSON.parse(text);
//            if (data.error) {
//              console.log("[Connection] RPC error:", JSON.stringify(data.error));
//              reject(new Error(data.error.message || "Unknown RPC error"));
//            } else if (data.result) {
//              console.log("[Connection] RPC success, balance:", data.result.value);
//              resolve(data.result.value);
//            } else {
//              console.log("[Connection] Unexpected RPC response format");
//              reject(new Error("Unexpected RPC response format"));
//            }
//          } catch (e) {
//            console.log("[Connection] Error parsing response:", e);
//            reject(e);
//          }
//        })
//        .catch(function(error) {
//          console.log("[Connection] Fetch error:", error);
//          console.log("[Connection] Falling back to mock balance");
//          // Fallback to mock balance for testing
//          resolve(5000000000); // 5 SOL in lamports
//        });
//      });
//    };
//  }
//
//  // Define a simplified PublicKey class
//  function PublicKey(address) {
//    if (!(this instanceof PublicKey)) {
//      return new PublicKey(address);
//    }
//
//    this._address = address;
//
//    this.toString = function() {
//      return this._address;
//    };
//
//    this.toBase58 = function() {
//      return this._address;
//    };
//
//    this.toJSON = function() {
//      return this._address;
//    };
//
//    this.equals = function(other) {
//      return this._address === other.toString();
//    };
//  }
//
//  // LAMPORTS_PER_SOL constant
//  const LAMPORTS_PER_SOL = 1000000000;
//
//  // Return the module
//  return {
//    Connection: Connection,
//    PublicKey: PublicKey,
//    LAMPORTS_PER_SOL: LAMPORTS_PER_SOL
//  };
//})();
//
//// Make it available globally
//if (typeof globalThis !== 'undefined') globalThis.solanaWeb3 = solanaWeb3;
//solanaWeb3; // Return value for immediate evaluation