//// simplified-solana-web3.js
//var solanaWeb3 = (function() {
//  // Define the Connection class with only the methods you need
//  function Connection(rpcUrl, commitment) {
//    this.rpcUrl = rpcUrl;
//    this.commitment = commitment || 'confirmed';
//
//    this.getBalance = function(publicKey) {
//      // Implementation that uses fetch to call the actual RPC endpoint
//      return new Promise((resolve, reject) => {
//        const body = JSON.stringify({
//          jsonrpc: "2.0",
//          id: 1,
//          method: "getBalance",
//          params: [
//            publicKey.toString(),
//            { commitment: this.commitment }
//          ]
//        });
//
//        // Log the request for debugging
//        console.log(`[Connection] Requesting balance for: ${publicKey.toString()}`);
//        console.log(`[Connection] Request body: ${body}`);
//
//        // Use the native fetch implementation provided by flutter_js
//        fetch(this.rpcUrl, {
//          method: 'POST',
//          headers: { 'Content-Type': 'application/json' },
//          body: body
//        })
//        .then(response => response.json())
//        .then(data => {
//          if (data.error) {
//            console.log(`[Connection] RPC error: ${JSON.stringify(data.error)}`);
//            reject(new Error(data.error.message));
//          } else {
//            console.log(`[Connection] Balance result: ${data.result.value}`);
//            resolve(data.result.value);
//          }
//        })
//        .catch(error => {
//          console.log(`[Connection] Fetch error: ${error}`);
//          reject(error);
//        });
//      });
//    };
//  }
//
//  // Define a simplified PublicKey class
//  function PublicKey(address) {
//    // Store the address
//    this._address = address;
//
//    // Return the string representation
//    this.toString = function() {
//      return this._address;
//    };
//
//    // For JSON serialization
//    this.toJSON = function() {
//      return this._address;
//    };
//  }
//
//  // LAMPORTS_PER_SOL constant
//  const LAMPORTS_PER_SOL = 1000000000;
//
//  // Return the module
//  return {
//    Connection: Connection,
//    PublicKey: PublicKey,
//    LAMPORTS_PER_SOL: LAMPORTS_PER_SOL
//  };
//})();
//
//// Make it available globally
//if (typeof globalThis !== 'undefined') globalThis.solanaWeb3 = solanaWeb3;
//solanaWeb3; // Return value for immediate evaluation

// simplified-solana-web3.js
var solanaWeb3 = (function() {
  // Define the Connection class with only the methods you need
  function Connection(rpcUrl, commitment) {
    this.rpcUrl = rpcUrl;
    this.commitment = commitment || 'confirmed';

    this.getBalance = function(publicKey) {
      console.log("[Connection] Getting balance for:", publicKey.toString());

      return new Promise(function(resolve, reject) {
        // Check if we have the fetch function
        if (typeof fetch !== 'function') {
          console.log("[Connection] fetch is not available");
          // Return mock balance for testing
          setTimeout(function() {
            console.log("[Connection] Using mock balance of 5 SOL");
            resolve(5000000000); // 5 SOL in lamports
          }, 1000);
          return;
        }

        // Prepare the JSON-RPC request
        var requestBody = JSON.stringify({
          jsonrpc: "2.0",
          id: 1,
          method: "getBalance",
          params: [
            publicKey.toString(),
            { commitment: commitment }
          ]
        });

        console.log("[Connection] Sending RPC request to:", rpcUrl);
        console.log("[Connection] Request body:", requestBody);

        // Make the RPC call
        fetch(rpcUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: requestBody
        })
        .then(function(response) {
          console.log("[Connection] RPC response received, status:", response.status);
          return response.text();
        })
        .then(function(text) {
          console.log("[Connection] Response text:", text);
          try {
            var data = JSON.parse(text);
            if (data.error) {
              console.log("[Connection] RPC error:", JSON.stringify(data.error));
              reject(new Error(data.error.message || "Unknown RPC error"));
            } else if (data.result) {
              console.log("[Connection] RPC success, balance:", data.result.value);
              resolve(data.result.value);
            } else {
              console.log("[Connection] Unexpected RPC response format");
              reject(new Error("Unexpected RPC response format"));
            }
          } catch (e) {
            console.log("[Connection] Error parsing response:", e);
            reject(e);
          }
        })
        .catch(function(error) {
          console.log("[Connection] Fetch error:", error);
          console.log("[Connection] Falling back to mock balance");
          // Fallback to mock balance for testing
          resolve(5000000000); // 5 SOL in lamports
        });
      });
    };
  }

  // Define a simplified PublicKey class
  function PublicKey(address) {
    if (!(this instanceof PublicKey)) {
      return new PublicKey(address);
    }

    this._address = address;

    this.toString = function() {
      return this._address;
    };

    this.toBase58 = function() {
      return this._address;
    };

    this.toJSON = function() {
      return this._address;
    };

    this.equals = function(other) {
      return this._address === other.toString();
    };
  }

  // LAMPORTS_PER_SOL constant
  const LAMPORTS_PER_SOL = 1000000000;

  // Return the module
  return {
    Connection: Connection,
    PublicKey: PublicKey,
    LAMPORTS_PER_SOL: LAMPORTS_PER_SOL
  };
})();

// Make it available globally
if (typeof globalThis !== 'undefined') globalThis.solanaWeb3 = solanaWeb3;
solanaWeb3; // Return value for immediate evaluation